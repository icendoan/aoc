grid â†  > â€¢file.Lines "3.in"
digits â†  '0' + â†• 10

# Part 1
MaskAdj â†  (Â«âŒˆÂ»âŒˆâŠ¢) {ğ”½Ë˜âˆ˜ğ”½} # if a 1 is in a cell, put a 1 in every adjacent cell
Extend â†  (âŒˆÃ—0â‰ âŠ¢)`{ğ”½âŒ¾âŒ½ ğ”½}Ë˜
ExtendDigitRanges â†  (1<âŠ¢) âˆ˜ Extend âˆ˜ (âˆ§+âŠ¢) # 'wash' intersections back and forward along the rows
ClassifyMaskâ† (+`Â»âŠ¸<)Ã—âŠ¢ # assigns each block of 1s in a mask a unique id

symbols â†  (digits âˆ¾ ".") (â· Â¬âˆ˜âˆŠËœ/âŠ¢) â¥Š grid # Anything but a digit or a dot
adjacent â†  MaskAdj grid âˆŠ symbols
matches â†  adjacent ExtendDigitRanges grid âˆŠ digits
â€¢Show p1 â†  +Â´ â€¢ParseFloatÂ¨ (matches âˆ¾ Ë˜ 0) (Â¯1+ClassifyMask)âŠ¸âŠ” â—‹  â¥Š  (grid âˆ¾ Ë˜ '.') 

# Part 2
CountDistinctNumbers â†  (âŒˆÂ´âˆ˜ClassifyMaskâˆ˜â¥Š  0 âˆ¾ Ë˜ âŠ¢ âˆŠ Digits) âˆ§ '*' = 1â€¿1 âŠ‘ âŠ¢ # Count the number of distinct numbers, including separated by end-of-row
has_two_numbers â†  MaskAdj 2 = m â†  Â¯1âŠ¸âŒ½{ğ”½ğ”½Ë˜} (â‰¢grid) â†‘  CountDistinctNumbersâ‰ 2 3â€¿3 â†• grid # Check each window for a) having a gear and b) having exactly 2 numbers in it
gears â†  has_two_numbers ExtendDigitRanges grid âˆŠ digits
paired â†  Extend gears (Ã—âŒˆâŠ£) MaskAdj ((âŠ¢Ã—+`)'*'=âŠ¢)âŒ¾â¥Š  grid # Give each gear a unique id, and extend it to the numbers around it, pairing them up
number_ids â†  Â¯1 + ClassifyMaskâŒ¾â¥Š  gears # Classify the numbers
all_gears â† â€¢ParseFloatÂ¨ number_ids âŠ”â—‹ â¥Š grid # Extract the numbers and parse
gear_ids â†  âŠ‘Â¨ number_ids âŠ”â—‹ â¥Š  paired # Group the pair ids by number id (and, because there are multi-digit numbers, take the first)

# Now gear_ids and all_gears have the same shape, and gear_ids is the pairing number for each digit adjacent to a gear

â€¢Show p2 â†  +Â´Ã—Â´Â¨ (0â‰ â‰ Â¨)âŠ¸/ gear_ids âŠ” all_gears
