dir: "URDL"!(1 0;0 1;-1 0;0 -1);                                                          / Map of direction to cartesian offset: R → 0 1, etc
parse:","\:';                                                                             / Split each line on comma, return an array of each split for each line: ("R1,L2,D3";"U10,R20,D30") → (("R1";"L2";"D3");("U10";"R20";"D30"))
decode: { dir[*x] * `i $ 1 _ x };                                                         / Look up the cartesian offset based on the first character, and then multiply it by the integer parse of the suffix: "R2" → 0 2
points: (,0 0) , 0 0 +\ decode';                                                          / Take each split directional segment and turn it into coordinate movements; then take all the sums of these, representing the points the wire changes direction
                                                                                          / and then finally add the origin to the path, since all wires start there implicitly.
spans:{|:' 1_ x ,': ,:' x};                                                               / join the input set of coordinates with their predecessors, reverse each of them, and drop the first. Array of coords becomes an array of steps. 
intersects: { &/ {x=~y} . x < y };                                                        / Take two coordinate steps (x0 x1 x2 x3) and (y0 y1 y2 y3) and checks if the order has inverted for start and end sets.
                                                                                          / If x0 x1 < y0 y1 and x2 x3 > y2 y3 then the lines intersect. Here < broadcasts fully, then . unpacks the 2-element array, checks pairwise for inversion and then we reduce with &
intersection:{,/ (+x 0 2) @' &:' (=) ./: 2 2 # x};                                        / Interpolates a segment that intersects, returning its intersection. The wires only move in cardinal directions, so the intersection is the unchanging coordinate from each pair, in that place.
overlaps:{[x;y] (,/x,/:\:y) @&,/ x intersects/:\: y};                                     / Checks all the pairs of steps (from `spans`) for intersection, and then returns an array of pairs of spans that do overlap.
length:{[x;y;z] +//+/' abs -':'(((x;y)?'z 1 3)#'(x;y)),\:,intersection z};                / From an intersecting span, take the prefix of wire to that intersection, add the intersection to the path, and then sum the distance of all the steps
p1:{[x] &/+/' abs' intersection' overlaps . spans' points' parse x };                     / Turn the input into arrays of spans, calculate their overlaps, infer their intersections, and then find the one that minimises the sum of the absolute value of the coordinates (manhattan distance) 
p2:{[x] (x;y):points' parse x; &/ length[x;y]' overlaps . spans' (x;y) };                 / Turn the input into arrays of points, calculate their intersections, and then find the prefix-length of each intersection, and minimise it.
